apiVersion: v1
kind: ConfigMap
metadata:
  name: node-taints-desired-state
  namespace: kube-system
  annotations:
    # This ConfigMap documents the desired taint state for worker nodes
    # Apply taints using: kubectl taint node <node-name> <key>=<value>:<effect>
    # Or use: talosctl patch machineconfig --patch @node-config-patch.yaml
data:
  k8s-worker-1.yaml: |
    # Desired taint configuration for k8s-worker-1
    # This should be applied to allow the node to complete full boot process
    # 
    # Recommended taint for AI workloads:
    # key: workload.ai-services
    # value: reserved
    # effect: NoSchedule
    #
    # To apply this taint, use:
    # kubectl taint node k8s-worker-1 workload.ai-services=reserved:NoSchedule
    #
    # This taint will:
    # - Prevent general workloads from being scheduled on this node
    # - Allow only pods with matching tolerations (ai-services workloads)
    # - Help ensure the node completes its full boot sequence before accepting workloads
    taint-key: workload.ai-services
    taint-value: reserved
    taint-effect: NoSchedule
  README.md: |
    # Node Taints Management
    
    ## GitOps Best Practice
    This ConfigMap documents the desired taint state for worker nodes.
    
    ## Applying Taints
    While Kubernetes doesn't support declarative taint management, you have these options:
    
    ### Option 1: Using kubectl (for initial setup)
    ```bash
    kubectl taint node k8s-worker-1 workload.ai-services=reserved:NoSchedule
    ```
    
    ### Option 2: Using Talos machine config patch
    Create a Talos patch file and apply it using:
    ```bash
    talosctl patch machineconfig --patch @your-patch-file.yaml
    ```
    
    ### Option 3: Using clustertool script
    Use your cluster management script to apply the taint:
    ```bash
    ./clustertool taint-node k8s-worker-1 workload.ai-services=reserved:NoSchedule
    ```
    
    ## Verifying Applied Taints
    ```bash
    kubectl describe node k8s-worker-1 | grep Taints
    ```

